
C:\Users\pc235\AppData\Local\Temp\arduino_build_659634/smol_Power_Board_AAA_ATtiny43U.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	29 c0       	rjmp	.+82     	; 0x56 <__bad_interrupt>
   4:	28 c0       	rjmp	.+80     	; 0x56 <__bad_interrupt>
   6:	27 c0       	rjmp	.+78     	; 0x56 <__bad_interrupt>
   8:	26 c0       	rjmp	.+76     	; 0x56 <__bad_interrupt>
   a:	25 c0       	rjmp	.+74     	; 0x56 <__bad_interrupt>
   c:	24 c0       	rjmp	.+72     	; 0x56 <__bad_interrupt>
   e:	23 c0       	rjmp	.+70     	; 0x56 <__bad_interrupt>
  10:	22 c0       	rjmp	.+68     	; 0x56 <__bad_interrupt>
  12:	21 c0       	rjmp	.+66     	; 0x56 <__bad_interrupt>
  14:	20 c0       	rjmp	.+64     	; 0x56 <__bad_interrupt>
  16:	1f c0       	rjmp	.+62     	; 0x56 <__bad_interrupt>
  18:	1e c0       	rjmp	.+60     	; 0x56 <__bad_interrupt>
  1a:	1d c0       	rjmp	.+58     	; 0x56 <__bad_interrupt>
  1c:	5c c2       	rjmp	.+1208   	; 0x4d6 <__vector_14>
  1e:	a4 c1       	rjmp	.+840    	; 0x368 <__vector_15>

00000020 <__ctors_start>:
__trampolines_start():
  20:	6b 04       	cpc	r6, r11

00000022 <__ctors_end>:
__dtors_end():
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf e5       	ldi	r28, 0x5F	; 95
  28:	d1 e0       	ldi	r29, 0x01	; 1
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  2e:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  30:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  32:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  34:	01 c0       	rjmp	.+2      	; 0x38 <.do_clear_bss_start>

00000036 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  36:	1d 92       	st	X+, r1

00000038 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  38:	af 3a       	cpi	r26, 0xAF	; 175
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  3a:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  3c:	e1 f7       	brne	.-8      	; 0x36 <.do_clear_bss_loop>

0000003e <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  3e:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  40:	c1 e1       	ldi	r28, 0x11	; 17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  42:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  44:	03 c0       	rjmp	.+6      	; 0x4c <__SREG__+0xd>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  46:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  48:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  4a:	6c d4       	rcall	.+2264   	; 0x924 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  4c:	c0 31       	cpi	r28, 0x10	; 16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  4e:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  50:	d1 f7       	brne	.-12     	; 0x46 <__SREG__+0x7>
  52:	88 d2       	rcall	.+1296   	; 0x564 <main>
  54:	6d c4       	rjmp	.+2266   	; 0x930 <_exit>

00000056 <__bad_interrupt>:
__vector_1():
  56:	d4 cf       	rjmp	.-88     	; 0x0 <__vectors>

00000058 <TwoWire::read() [clone .constprop.15]>:
_ZN7TwoWire4readEv.constprop.15():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:551

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  if (BufferLength) {
  58:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <TwoWire::BufferLength>
  5c:	88 23       	and	r24, r24
  5e:	39 f0       	breq	.+14     	; 0x6e <TwoWire::read() [clone .constprop.15]+0x16>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:552
    return BufferLength - BufferIndex;
  60:	20 91 ad 00 	lds	r18, 0x00AD	; 0x8000ad <TwoWire::BufferIndex>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:565
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
  64:	82 13       	cpse	r24, r18
  66:	1c c0       	rjmp	.+56     	; 0xa0 <TwoWire::read() [clone .constprop.15]+0x48>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:562

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
  68:	8f ef       	ldi	r24, 0xFF	; 255
  6a:	9f ef       	ldi	r25, 0xFF	; 255
  6c:	08 95       	ret
USI_TWI_Data_In_Receive_Buffer():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
  6e:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
  72:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <TWI_RxHead>
  76:	89 1b       	sub	r24, r25
  78:	8f 70       	andi	r24, 0x0F	; 15
_ZN7TwoWire4readEv.constprop.15():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:565

  // get each successive byte on each call
  if (available()) {
  7a:	b1 f3       	breq	.-20     	; 0x68 <TwoWire::read() [clone .constprop.15]+0x10>
USI_TWI_Receive_Byte():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:112
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
  unsigned char tmptail;
  unsigned char tmpRxTail; // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
  7c:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:113
  while (TWI_RxHead == tmpRxTail)
  80:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <TWI_RxHead>
  84:	98 17       	cp	r25, r24
  86:	e1 f3       	breq	.-8      	; 0x80 <TwoWire::read() [clone .constprop.15]+0x28>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:115
    ;
  tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
  88:	e0 91 ac 00 	lds	r30, 0x00AC	; 0x8000ac <TWI_RxTail>
  8c:	ef 5f       	subi	r30, 0xFF	; 255
  8e:	ef 70       	andi	r30, 0x0F	; 15
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:116
  TWI_RxTail = tmptail;                               // Store new index
  90:	e0 93 ac 00 	sts	0x00AC, r30	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:117
  return TWI_RxBuf[tmptail];                          // Return data from the buffer.
  94:	f0 e0       	ldi	r31, 0x00	; 0
  96:	e0 5a       	subi	r30, 0xA0	; 160
  98:	ff 4f       	sbci	r31, 0xFF	; 255
_ZN7TwoWire4readEv.constprop.15():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:570
    if (BufferLength) {
      value = Buffer[BufferIndex];
      ++BufferIndex;
    } else {
      value = USI_TWI_Receive_Byte();
  9a:	80 81       	ld	r24, Z
  9c:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:575
    }
  }

  return value;
}
  9e:	08 95       	ret
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:567
  int value = -1;

  // get each successive byte on each call
  if (available()) {
    if (BufferLength) {
      value = Buffer[BufferIndex];
  a0:	e2 2f       	mov	r30, r18
  a2:	f0 e0       	ldi	r31, 0x00	; 0
  a4:	e0 5a       	subi	r30, 0xA0	; 160
  a6:	ff 4f       	sbci	r31, 0xFF	; 255
  a8:	80 81       	ld	r24, Z
  aa:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:568
      ++BufferIndex;
  ac:	2f 5f       	subi	r18, 0xFF	; 255
  ae:	20 93 ad 00 	sts	0x00AD, r18	; 0x8000ad <TwoWire::BufferIndex>
  b2:	08 95       	ret

000000b4 <TwoWire::write(unsigned char) [clone .constprop.14]>:
_ZN7TwoWire5writeEh.constprop.14():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:507

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
  b4:	90 91 aa 00 	lds	r25, 0x00AA	; 0x8000aa <TwoWire::transmitting>
  b8:	99 23       	and	r25, r25
  ba:	a1 f0       	breq	.+40     	; 0xe4 <TwoWire::write(unsigned char) [clone .constprop.14]+0x30>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:509
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
  bc:	90 91 ae 00 	lds	r25, 0x00AE	; 0x8000ae <TwoWire::BufferLength>
  c0:	90 32       	cpi	r25, 0x20	; 32
  c2:	40 f5       	brcc	.+80     	; 0x114 <TwoWire::write(unsigned char) [clone .constprop.14]+0x60>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:513
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
  c4:	90 91 ad 00 	lds	r25, 0x00AD	; 0x8000ad <TwoWire::BufferIndex>
  c8:	e9 2f       	mov	r30, r25
  ca:	f0 e0       	ldi	r31, 0x00	; 0
  cc:	e0 5a       	subi	r30, 0xA0	; 160
  ce:	ff 4f       	sbci	r31, 0xFF	; 255
  d0:	80 83       	st	Z, r24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:514
    ++BufferIndex;
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	89 0f       	add	r24, r25
  d6:	80 93 ad 00 	sts	0x00AD, r24	; 0x8000ad <TwoWire::BufferIndex>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:516
    // update amount in buffer
    BufferLength = BufferIndex;
  da:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <TwoWire::BufferLength>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:525
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
  de:	81 e0       	ldi	r24, 0x01	; 1
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	08 95       	ret
USI_TWI_Space_In_Transmission_Buffer():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
  e4:	20 91 a9 00 	lds	r18, 0x00A9	; 0x8000a9 <TWI_TxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
  e8:	90 91 a8 00 	lds	r25, 0x00A8	; 0x8000a8 <TWI_TxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
  ec:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
  ee:	92 1b       	sub	r25, r18
  f0:	9f 70       	andi	r25, 0x0F	; 15
_ZN7TwoWire5writeEh.constprop.14():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:519
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
  f2:	81 f0       	breq	.+32     	; 0x114 <TwoWire::write(unsigned char) [clone .constprop.14]+0x60>
USI_TWI_Transmit_Byte():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
  f4:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <TWI_TxHead>
  f8:	9f 5f       	subi	r25, 0xFF	; 255
  fa:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
  fc:	20 91 a8 00 	lds	r18, 0x00A8	; 0x8000a8 <TWI_TxTail>
 100:	92 17       	cp	r25, r18
 102:	e1 f3       	breq	.-8      	; 0xfc <TwoWire::write(unsigned char) [clone .constprop.14]+0x48>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 104:	e9 2f       	mov	r30, r25
 106:	f0 e0       	ldi	r31, 0x00	; 0
 108:	e0 59       	subi	r30, 0x90	; 144
 10a:	ff 4f       	sbci	r31, 0xFF	; 255
 10c:	80 83       	st	Z, r24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
 10e:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <TWI_TxHead>
 112:	e5 cf       	rjmp	.-54     	; 0xde <TwoWire::write(unsigned char) [clone .constprop.14]+0x2a>
_ZN7TwoWire5writeEh.constprop.14():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:510
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
      return 0;
 114:	90 e0       	ldi	r25, 0x00	; 0
 116:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:526
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
}
 118:	08 95       	ret

0000011a <TwoWire::write(unsigned char const*, unsigned int) [clone .constprop.12]>:
_ZN7TwoWire5writeEPKhj.constprop.12():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:531

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
 11a:	0f 93       	push	r16
 11c:	1f 93       	push	r17
 11e:	cf 93       	push	r28
 120:	df 93       	push	r29
 122:	ec 01       	movw	r28, r24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:534
  size_t numBytes = 0;
  for (size_t i = 0; i < quantity; ++i){
    numBytes += write(data[i]);
 124:	88 81       	ld	r24, Y
 126:	c6 df       	rcall	.-116    	; 0xb4 <TwoWire::write(unsigned char) [clone .constprop.14]>
 128:	8c 01       	movw	r16, r24
 12a:	89 81       	ldd	r24, Y+1	; 0x01
 12c:	c3 df       	rcall	.-122    	; 0xb4 <TwoWire::write(unsigned char) [clone .constprop.14]>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:537
  }
  return numBytes;
}
 12e:	80 0f       	add	r24, r16
 130:	91 1f       	adc	r25, r17
 132:	df 91       	pop	r29
 134:	cf 91       	pop	r28
 136:	1f 91       	pop	r17
 138:	0f 91       	pop	r16
 13a:	08 95       	ret

0000013c <noIntDelay(unsigned char) [clone .constprop.3]>:
_Z10noIntDelayh.constprop.3():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:274
 13c:	cf 93       	push	r28
 13e:	df 93       	push	r29
 140:	00 d0       	rcall	.+0      	; 0x142 <noIntDelay(unsigned char) [clone .constprop.3]+0x6>
 142:	1f 92       	push	r1
 144:	cd b7       	in	r28, 0x3d	; 61
 146:	de b7       	in	r29, 0x3e	; 62
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:276
 148:	1b 82       	std	Y+3, r1	; 0x03
 14a:	8b 81       	ldd	r24, Y+3	; 0x03
 14c:	81 11       	cpse	r24, r1
 14e:	12 c0       	rjmp	.+36     	; 0x174 <__stack+0x15>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:279
 150:	1a 82       	std	Y+2, r1	; 0x02
 152:	19 82       	std	Y+1, r1	; 0x01
 154:	89 81       	ldd	r24, Y+1	; 0x01
 156:	9a 81       	ldd	r25, Y+2	; 0x02
 158:	8f 3a       	cpi	r24, 0xAF	; 175
 15a:	91 05       	cpc	r25, r1
 15c:	38 f4       	brcc	.+14     	; 0x16c <__stack+0xd>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:281
 15e:	00 00       	nop
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:279
 160:	89 81       	ldd	r24, Y+1	; 0x01
 162:	9a 81       	ldd	r25, Y+2	; 0x02
 164:	01 96       	adiw	r24, 0x01	; 1
 166:	9a 83       	std	Y+2, r25	; 0x02
 168:	89 83       	std	Y+1, r24	; 0x01
 16a:	f4 cf       	rjmp	.-24     	; 0x154 <noIntDelay(unsigned char) [clone .constprop.3]+0x18>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:276
 16c:	8b 81       	ldd	r24, Y+3	; 0x03
 16e:	8f 5f       	subi	r24, 0xFF	; 255
 170:	8b 83       	std	Y+3, r24	; 0x03
 172:	eb cf       	rjmp	.-42     	; 0x14a <noIntDelay(unsigned char) [clone .constprop.3]+0xe>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:284
 174:	0f 90       	pop	r0
 176:	0f 90       	pop	r0
 178:	0f 90       	pop	r0
 17a:	df 91       	pop	r29
 17c:	cf 91       	pop	r28
 17e:	08 95       	ret

00000180 <analogRead>:
analogRead():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:72
  #ifndef ADCSRA
  return digitalRead(analogInputToDigitalPin(pin)) ? 1023 : 0; //No ADC, so read as a digital pin instead.
  #endif

  #if defined(ADMUX)
  ADMUX = ((analog_reference & ADMUX_REFS_MASK) << REFS0) | ((pin & ADMUX_MUX_MASK) << MUX0); //select the channel and reference
 180:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <analog_reference>
 184:	92 95       	swap	r25
 186:	99 0f       	add	r25, r25
 188:	99 0f       	add	r25, r25
 18a:	90 74       	andi	r25, 0x40	; 64
 18c:	87 70       	andi	r24, 0x07	; 7
 18e:	98 2b       	or	r25, r24
 190:	97 b9       	out	0x07, r25	; 7
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:79
  ADMUX |= (((analog_reference & 0x04) >> 2) << REFS2); //some have an extra reference bit in a weird position.
  #endif
  #endif

  #if defined(HAVE_ADC) && HAVE_ADC
  sbi(ADCSRA, ADSC); //Start conversion
 192:	36 9a       	sbi	0x06, 6	; 6
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:81

  while(ADCSRA & (1<<ADSC)); //Wait for conversion to complete.
 194:	36 99       	sbic	0x06, 6	; 6
 196:	fe cf       	rjmp	.-4      	; 0x194 <analogRead+0x14>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:83

  uint8_t low = ADCL;
 198:	84 b1       	in	r24, 0x04	; 4
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:84
  uint8_t high = ADCH;
 19a:	95 b1       	in	r25, 0x05	; 5
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:89
  return (high << 8) | low;
  #else
  return LOW;
  #endif
}
 19c:	08 95       	ret

0000019e <USI_TWI_Slave_Initialise>:
USI_TWI_Slave_Initialise():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:54
static volatile uint8_t TWI_TxHead;
static volatile uint8_t TWI_TxTail;

void Flush_TWI_Buffers(void)
{
  TWI_RxTail = 0;
 19e:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:55
  TWI_RxHead = 0;
 1a2:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <TWI_RxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:56
  TWI_TxTail = 0;
 1a6:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <TWI_TxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:57
  TWI_TxHead = 0;
 1aa:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <TWI_TxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:69
----------------------------------------------------------*/
void USI_TWI_Slave_Initialise(unsigned char TWI_ownAddress)
{
  Flush_TWI_Buffers();

  TWI_slaveAddress = TWI_ownAddress;
 1ae:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <TWI_slaveAddress>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:71

  USI_TWI_On_Slave_Transmit = 0;
 1b2:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <USI_TWI_On_Slave_Transmit+0x1>
 1b6:	10 92 83 00 	sts	0x0083, r1	; 0x800083 <USI_TWI_On_Slave_Transmit>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:72
  USI_TWI_On_Slave_Receive = 0;
 1ba:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <USI_TWI_On_Slave_Receive+0x1>
 1be:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <USI_TWI_On_Slave_Receive>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:74

  PORT_USI_CL |= (1 << PORT_USI_SCL);     // Set SCL high
 1c2:	c6 9a       	sbi	0x18, 6	; 24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:75
  PORT_USI |= (1 << PORT_USI_SDA);        // Set SDA high
 1c4:	c4 9a       	sbi	0x18, 4	; 24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:76
  DDR_USI_CL |= (1 << PORT_USI_SCL);      // Set SCL as output
 1c6:	be 9a       	sbi	0x17, 6	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:77
  DDR_USI &= ~(1 << PORT_USI_SDA);        // Set SDA as input
 1c8:	bc 98       	cbi	0x17, 4	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:78
  USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 1ca:	88 ea       	ldi	r24, 0xA8	; 168
 1cc:	8d b9       	out	0x0d, r24	; 13
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:83
          (1 << USIWM1) | (0 << USIWM0) | // Set USI in Two-wire mode. No USI Counter overflow prior
                                          // to first Start Condition (potential failure)
          (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
          (0 << USITC);
  USISR = 0xF0; // Clear all flags and reset overflow counter
 1ce:	80 ef       	ldi	r24, 0xF0	; 240
 1d0:	8e b9       	out	0x0e, r24	; 14
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:84
}
 1d2:	08 95       	ret

000001d4 <requestEvent()>:
_Z12requestEventv():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:30
 1d4:	cf 93       	push	r28
 1d6:	df 93       	push	r29
 1d8:	00 d0       	rcall	.+0      	; 0x1da <requestEvent()+0x6>
 1da:	cd b7       	in	r28, 0x3d	; 61
 1dc:	de b7       	in	r29, 0x3e	; 62
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:32
 1de:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <receiveEventData>
 1e2:	84 30       	cpi	r24, 0x04	; 4
 1e4:	a9 f1       	breq	.+106    	; 0x250 <requestEvent()+0x7c>
 1e6:	58 f4       	brcc	.+22     	; 0x1fe <requestEvent()+0x2a>
 1e8:	81 30       	cpi	r24, 0x01	; 1
 1ea:	01 f1       	breq	.+64     	; 0x22c <requestEvent()+0x58>
 1ec:	d8 f0       	brcs	.+54     	; 0x224 <requestEvent()+0x50>
 1ee:	82 30       	cpi	r24, 0x02	; 2
 1f0:	01 f1       	breq	.+64     	; 0x232 <requestEvent()+0x5e>
 1f2:	83 30       	cpi	r24, 0x03	; 3
 1f4:	41 f1       	breq	.+80     	; 0x246 <requestEvent()+0x72>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:82
 1f6:	8f ef       	ldi	r24, 0xFF	; 255
 1f8:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <receiveEventData>
 1fc:	0e c0       	rjmp	.+28     	; 0x21a <requestEvent()+0x46>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:32
 1fe:	87 30       	cpi	r24, 0x07	; 7
 200:	79 f1       	breq	.+94     	; 0x260 <requestEvent()+0x8c>
 202:	38 f4       	brcc	.+14     	; 0x212 <requestEvent()+0x3e>
 204:	85 30       	cpi	r24, 0x05	; 5
 206:	49 f1       	breq	.+82     	; 0x25a <requestEvent()+0x86>
 208:	86 30       	cpi	r24, 0x06	; 6
 20a:	a9 f7       	brne	.-22     	; 0x1f6 <requestEvent()+0x22>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:65
 20c:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <eeprom_settings+0x3>
 210:	0b c0       	rjmp	.+22     	; 0x228 <requestEvent()+0x54>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:32
 212:	89 30       	cpi	r24, 0x09	; 9
 214:	51 f1       	breq	.+84     	; 0x26a <requestEvent()+0x96>
 216:	8f 3f       	cpi	r24, 0xFF	; 255
 218:	71 f7       	brne	.-36     	; 0x1f6 <requestEvent()+0x22>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:85
 21a:	0f 90       	pop	r0
 21c:	0f 90       	pop	r0
 21e:	df 91       	pop	r29
 220:	cf 91       	pop	r28
 222:	08 95       	ret
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:35
 224:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <eeprom_settings+0x2>
write():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.h:157
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
 228:	45 df       	rcall	.-374    	; 0xb4 <TwoWire::write(unsigned char) [clone .constprop.14]>
 22a:	e5 cf       	rjmp	.-54     	; 0x1f6 <requestEvent()+0x22>
_Z12requestEventv():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:39
 22c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <registerResetReason>
 230:	fb cf       	rjmp	.-10     	; 0x228 <requestEvent()+0x54>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:43
 232:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <registerTemperature>
 236:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <registerTemperature+0x1>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:69
 23a:	99 83       	std	Y+1, r25	; 0x01
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:70
 23c:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:71
 23e:	ce 01       	movw	r24, r28
 240:	01 96       	adiw	r24, 0x01	; 1
 242:	6b df       	rcall	.-298    	; 0x11a <TwoWire::write(unsigned char const*, unsigned int) [clone .constprop.12]>
 244:	d8 cf       	rjmp	.-80     	; 0x1f6 <requestEvent()+0x22>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:49
 246:	90 91 89 00 	lds	r25, 0x0089	; 0x800089 <registerVBAT>
 24a:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <registerVBAT+0x1>
 24e:	f5 cf       	rjmp	.-22     	; 0x23a <requestEvent()+0x66>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:55
 250:	90 91 8c 00 	lds	r25, 0x008C	; 0x80008c <registerVCCVoltage>
 254:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <registerVCCVoltage+0x1>
 258:	f0 cf       	rjmp	.-32     	; 0x23a <requestEvent()+0x66>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:61
 25a:	80 91 8e 00 	lds	r24, 0x008E	; 0x80008e <registerADCReference>
 25e:	e4 cf       	rjmp	.-56     	; 0x228 <requestEvent()+0x54>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:69
 260:	90 91 93 00 	lds	r25, 0x0093	; 0x800093 <eeprom_settings+0x4>
 264:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <eeprom_settings+0x5>
 268:	e8 cf       	rjmp	.-48     	; 0x23a <requestEvent()+0x66>
write():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.h:157
 26a:	80 e1       	ldi	r24, 0x10	; 16
 26c:	dd cf       	rjmp	.-70     	; 0x228 <requestEvent()+0x54>

0000026e <receiveEvent(int)>:
_Z12receiveEventi():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:6
 26e:	ef 92       	push	r14
 270:	ff 92       	push	r15
 272:	0f 93       	push	r16
 274:	1f 93       	push	r17
 276:	cf 93       	push	r28
 278:	df 93       	push	r29
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:7
 27a:	18 16       	cp	r1, r24
 27c:	19 06       	cpc	r1, r25
 27e:	7c f4       	brge	.+30     	; 0x29e <receiveEvent(int)+0x30>
 280:	8c 01       	movw	r16, r24
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:9
 282:	ea de       	rcall	.-556    	; 0x58 <TwoWire::read() [clone .constprop.15]>
 284:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <receiveEventData>
 288:	87 e9       	ldi	r24, 0x97	; 151
 28a:	e8 2e       	mov	r14, r24
 28c:	80 e0       	ldi	r24, 0x00	; 0
 28e:	f8 2e       	mov	r15, r24
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:15
 290:	c1 e0       	ldi	r28, 0x01	; 1
 292:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:12
 294:	01 30       	cpi	r16, 0x01	; 1
 296:	11 05       	cpc	r17, r1
 298:	61 f4       	brne	.+24     	; 0x2b2 <receiveEvent(int)+0x44>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:23
 29a:	00 93 a7 00 	sts	0x00A7, r16	; 0x8000a7 <receiveEventData+0x11>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:25
 29e:	df 91       	pop	r29
 2a0:	cf 91       	pop	r28
 2a2:	1f 91       	pop	r17
 2a4:	0f 91       	pop	r16
 2a6:	ff 90       	pop	r15
 2a8:	ef 90       	pop	r14
 2aa:	08 95       	ret
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:15
 2ac:	c0 31       	cpi	r28, 0x10	; 16
 2ae:	d1 05       	cpc	r29, r1
 2b0:	41 f0       	breq	.+16     	; 0x2c2 <receiveEvent(int)+0x54>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:17
 2b2:	d2 de       	rcall	.-604    	; 0x58 <TwoWire::read() [clone .constprop.15]>
 2b4:	f7 01       	movw	r30, r14
 2b6:	81 93       	st	Z+, r24
 2b8:	7f 01       	movw	r14, r30
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:15
 2ba:	21 96       	adiw	r28, 0x01	; 1
 2bc:	c0 17       	cp	r28, r16
 2be:	d1 07       	cpc	r29, r17
 2c0:	ac f3       	brlt	.-22     	; 0x2ac <receiveEvent(int)+0x3e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:20
 2c2:	ca 56       	subi	r28, 0x6A	; 106
 2c4:	df 4f       	sbci	r29, 0xFF	; 255
 2c6:	18 82       	st	Y, r1
 2c8:	e8 cf       	rjmp	.-48     	; 0x29a <receiveEvent(int)+0x2c>

000002ca <computeCRC8(unsigned char*, unsigned char)>:
_Z11computeCRC8Phh():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:51
 2ca:	28 2f       	mov	r18, r24
 2cc:	fc 01       	movw	r30, r24
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:52
 2ce:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:61
 2d0:	31 e3       	ldi	r19, 0x31	; 49
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:54
 2d2:	9e 2f       	mov	r25, r30
 2d4:	92 1b       	sub	r25, r18
 2d6:	96 17       	cp	r25, r22
 2d8:	60 f4       	brcc	.+24     	; 0x2f2 <computeCRC8(unsigned char*, unsigned char)+0x28>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:56
 2da:	91 91       	ld	r25, Z+
 2dc:	89 27       	eor	r24, r25
 2de:	98 e0       	ldi	r25, 0x08	; 8
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:60
 2e0:	87 ff       	sbrs	r24, 7
 2e2:	05 c0       	rjmp	.+10     	; 0x2ee <computeCRC8(unsigned char*, unsigned char)+0x24>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:61
 2e4:	88 0f       	add	r24, r24
 2e6:	83 27       	eor	r24, r19
 2e8:	91 50       	subi	r25, 0x01	; 1
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:58
 2ea:	d1 f7       	brne	.-12     	; 0x2e0 <computeCRC8(unsigned char*, unsigned char)+0x16>
 2ec:	f2 cf       	rjmp	.-28     	; 0x2d2 <computeCRC8(unsigned char*, unsigned char)+0x8>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:63
 2ee:	88 0f       	add	r24, r24
 2f0:	fb cf       	rjmp	.-10     	; 0x2e8 <computeCRC8(unsigned char*, unsigned char)+0x1e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:68
 2f2:	08 95       	ret

000002f4 <unsigned char& EEPROMClass::get<unsigned char>(int, unsigned char&) [clone .isra.1] [clone .constprop.11]>:
_ZN11EEPROMClass3getIhEERT_iS2_.isra.1.constprop.11():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:145
    EEPtr begin()                        { return 0x00; }
    EEPtr end()                          { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
    uint16_t length()                    { return E2END + 1; }

    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
 2f4:	cf 93       	push	r28
 2f6:	df 93       	push	r29
 2f8:	eb 01       	movw	r28, r22
operator*():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:53

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
 2fa:	00 d3       	rcall	.+1536   	; 0x8fc <eeprom_read_byte>
_ZN11EEPROMClass3getIhEERT_iS2_.isra.1.constprop.11():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:148

    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
 2fc:	88 83       	st	Y, r24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:150
        return t;
    }
 2fe:	ce 01       	movw	r24, r28
 300:	df 91       	pop	r29
 302:	cf 91       	pop	r28
 304:	08 95       	ret

00000306 <digitalWrite.constprop.2>:
digitalWrite.constprop.2():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 306:	81 11       	cpse	r24, r1
 308:	05 c0       	rjmp	.+10     	; 0x314 <digitalWrite.constprop.2+0xe>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153
    uint8_t oldSREG = SREG;
 30a:	8f b7       	in	r24, 0x3f	; 63
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    cli();
 30c:	f8 94       	cli
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
 30e:	db 98       	cbi	0x1b, 3	; 27
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
    SREG = oldSREG;
 310:	8f bf       	out	0x3f, r24	; 63
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
 312:	08 95       	ret
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:158
    uint8_t oldSREG = SREG;
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 314:	8f b7       	in	r24, 0x3f	; 63
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
 316:	f8 94       	cli
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 318:	db 9a       	sbi	0x1b, 3	; 27
 31a:	fa cf       	rjmp	.-12     	; 0x310 <digitalWrite.constprop.2+0xa>

0000031c <saveEepromSettings()>:
_Z18saveEepromSettingsv():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:29
 31c:	ff 92       	push	r15
 31e:	0f 93       	push	r16
 320:	1f 93       	push	r17
 322:	cf 93       	push	r28
 324:	df 93       	push	r29
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:30
 326:	87 e0       	ldi	r24, 0x07	; 7
 328:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <eeprom_settings>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:31
 32c:	66 e0       	ldi	r22, 0x06	; 6
 32e:	8f e8       	ldi	r24, 0x8F	; 143
 330:	90 e0       	ldi	r25, 0x00	; 0
 332:	cb df       	rcall	.-106    	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
 334:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <eeprom_settings+0x6>
 338:	0f e8       	ldi	r16, 0x8F	; 143
 33a:	10 e0       	ldi	r17, 0x00	; 0
 33c:	d0 e0       	ldi	r29, 0x00	; 0
 33e:	c0 e0       	ldi	r28, 0x00	; 0
_ZN11EEPROMClass3putI22struct_eeprom_settingsEERKT_iS4_.isra.3():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:155

    template< typename T > const T &put( int idx, const T &t ){
        EEPtr e = idx;
        const uint8_t *ptr = (const uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  (*e).update( *ptr++ );
 340:	f8 01       	movw	r30, r16
 342:	f1 90       	ld	r15, Z+
 344:	8f 01       	movw	r16, r30
operator*():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:53

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
 346:	ce 01       	movw	r24, r28
 348:	d9 d2       	rcall	.+1458   	; 0x8fc <eeprom_read_byte>
update():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:74
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
 34a:	f8 16       	cp	r15, r24
 34c:	19 f0       	breq	.+6      	; 0x354 <saveEepromSettings()+0x38>
_ZN5EERefaSEh():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:61
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    #if  (defined(__AVR_ATtinyX41__) && F_CPU==16000000 && CLOCK_SOURCE==0)
      EERef &operator=( uint8_t in )       { return safe_eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    #else
      EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
 34e:	6f 2d       	mov	r22, r15
 350:	ce 01       	movw	r24, r28
 352:	db d2       	rcall	.+1462   	; 0x90a <eeprom_write_byte>
 354:	21 96       	adiw	r28, 0x01	; 1
_ZN11EEPROMClass3putI22struct_eeprom_settingsEERKT_iS4_.isra.3():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:155
    }

    template< typename T > const T &put( int idx, const T &t ){
        EEPtr e = idx;
        const uint8_t *ptr = (const uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  (*e).update( *ptr++ );
 356:	c7 30       	cpi	r28, 0x07	; 7
 358:	d1 05       	cpc	r29, r1
 35a:	91 f7       	brne	.-28     	; 0x340 <saveEepromSettings()+0x24>
_Z18saveEepromSettingsv():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:33
 35c:	df 91       	pop	r29
 35e:	cf 91       	pop	r28
 360:	1f 91       	pop	r17
 362:	0f 91       	pop	r16
 364:	ff 90       	pop	r15
 366:	08 95       	ret

00000368 <__vector_15>:
__vector_15():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:207
/*----------------------------------------------------------
 Handles all the communication. Is disabled only when waiting
 for new Start Condition.
----------------------------------------------------------*/
ISR(USI_OVERFLOW_VECTOR)
{
 368:	1f 92       	push	r1
 36a:	0f 92       	push	r0
 36c:	0f b6       	in	r0, 0x3f	; 63
 36e:	0f 92       	push	r0
 370:	11 24       	eor	r1, r1
 372:	2f 93       	push	r18
 374:	3f 93       	push	r19
 376:	4f 93       	push	r20
 378:	5f 93       	push	r21
 37a:	6f 93       	push	r22
 37c:	7f 93       	push	r23
 37e:	8f 93       	push	r24
 380:	9f 93       	push	r25
 382:	af 93       	push	r26
 384:	bf 93       	push	r27
 386:	cf 93       	push	r28
 388:	ef 93       	push	r30
 38a:	ff 93       	push	r31
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 38c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <USI_TWI_Overflow_State>
 390:	82 30       	cpi	r24, 0x02	; 2
 392:	09 f4       	brne	.+2      	; 0x396 <__vector_15+0x2e>
 394:	74 c0       	rjmp	.+232    	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
 396:	b8 f4       	brcc	.+46     	; 0x3c6 <__vector_15+0x5e>
 398:	88 23       	and	r24, r24
 39a:	89 f1       	breq	.+98     	; 0x3fe <__vector_15+0x96>
 39c:	81 30       	cpi	r24, 0x01	; 1
 39e:	09 f4       	brne	.+2      	; 0x3a2 <__vector_15+0x3a>
 3a0:	54 c0       	rjmp	.+168    	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 3a2:	ff 91       	pop	r31
 3a4:	ef 91       	pop	r30
 3a6:	cf 91       	pop	r28
 3a8:	bf 91       	pop	r27
 3aa:	af 91       	pop	r26
 3ac:	9f 91       	pop	r25
 3ae:	8f 91       	pop	r24
 3b0:	7f 91       	pop	r23
 3b2:	6f 91       	pop	r22
 3b4:	5f 91       	pop	r21
 3b6:	4f 91       	pop	r20
 3b8:	3f 91       	pop	r19
 3ba:	2f 91       	pop	r18
 3bc:	0f 90       	pop	r0
 3be:	0f be       	out	0x3f, r0	; 63
 3c0:	0f 90       	pop	r0
 3c2:	1f 90       	pop	r1
 3c4:	18 95       	reti
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 3c6:	84 30       	cpi	r24, 0x04	; 4
 3c8:	09 f4       	brne	.+2      	; 0x3cc <__vector_15+0x64>
 3ca:	5f c0       	rjmp	.+190    	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
 3cc:	b8 f1       	brcs	.+110    	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
 3ce:	85 30       	cpi	r24, 0x05	; 5
 3d0:	41 f7       	brne	.-48     	; 0x3a2 <__vector_15+0x3a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:293
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 3d2:	84 e0       	ldi	r24, 0x04	; 4
 3d4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:294
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 3d8:	9f b1       	in	r25, 0x0f	; 15
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:295
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 3da:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <TWI_RxHead>
 3de:	8f 5f       	subi	r24, 0xFF	; 255
 3e0:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:296
    if (TWI_RxTail != tmpRxHead) {
 3e2:	20 91 ac 00 	lds	r18, 0x00AC	; 0x8000ac <TWI_RxTail>
 3e6:	28 17       	cp	r18, r24
 3e8:	09 f4       	brne	.+2      	; 0x3ec <__vector_15+0x84>
 3ea:	73 c0       	rjmp	.+230    	; 0x4d2 <__LOCK_REGION_LENGTH__+0xd2>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:297
      TWI_RxHead            = tmpRxHead;
 3ec:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <TWI_RxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:298
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 3f0:	e0 91 ab 00 	lds	r30, 0x00AB	; 0x8000ab <TWI_RxHead>
 3f4:	f0 e0       	ldi	r31, 0x00	; 0
 3f6:	e0 5a       	subi	r30, 0xA0	; 160
 3f8:	ff 4f       	sbci	r31, 0xFF	; 255
 3fa:	90 83       	st	Z, r25
 3fc:	19 c0       	rjmp	.+50     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:216

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 3fe:	8f b1       	in	r24, 0x0f	; 15
 400:	88 23       	and	r24, r24
 402:	31 f0       	breq	.+12     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 404:	8f b1       	in	r24, 0x0f	; 15
 406:	86 95       	lsr	r24
 408:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <TWI_slaveAddress>
 40c:	89 13       	cpse	r24, r25
 40e:	19 c0       	rjmp	.+50     	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
      if (USIDR & 0x01) {
 410:	78 9b       	sbis	0x0f, 0	; 15
 412:	12 c0       	rjmp	.+36     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:218
        if (USI_TWI_On_Slave_Transmit) {
 414:	e0 91 83 00 	lds	r30, 0x0083	; 0x800083 <USI_TWI_On_Slave_Transmit>
 418:	f0 91 84 00 	lds	r31, 0x0084	; 0x800084 <USI_TWI_On_Slave_Transmit+0x1>
 41c:	30 97       	sbiw	r30, 0x00	; 0
 41e:	29 f0       	breq	.+10     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:220
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
 420:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <TWI_TxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:221
          TWI_TxTail = tmpTxTail;
 424:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <TWI_TxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:222
          USI_TWI_On_Slave_Transmit();
 428:	09 95       	icall
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:224
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 42a:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 42c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:228
      }
      SET_USI_TO_SEND_ACK();
 430:	1f b8       	out	0x0f, r1	; 15
 432:	bc 9a       	sbi	0x17, 4	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 434:	8e e7       	ldi	r24, 0x7E	; 126
 436:	21 c0       	rjmp	.+66     	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 438:	84 e0       	ldi	r24, 0x04	; 4
 43a:	f8 cf       	rjmp	.-16     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:237
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 43c:	8f b1       	in	r24, 0x0f	; 15
 43e:	88 23       	and	r24, r24
 440:	21 f0       	breq	.+8      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 442:	bc 98       	cbi	0x17, 4	; 23
 444:	88 ea       	ldi	r24, 0xA8	; 168
 446:	8d b9       	out	0x0d, r24	; 13
 448:	17 c0       	rjmp	.+46     	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:249
  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  /* Falls through. */
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 44a:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <TWI_TxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:250
    if (TWI_TxHead != tmpTxTail) {
 44e:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <TWI_TxHead>
 452:	98 17       	cp	r25, r24
 454:	b1 f3       	breq	.-20     	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:251
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 456:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <TWI_TxTail>
 45a:	8f 5f       	subi	r24, 0xFF	; 255
 45c:	8f 70       	andi	r24, 0x0F	; 15
 45e:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <TWI_TxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:252
      USIDR      = TWI_TxBuf[TWI_TxTail];
 462:	e0 91 a8 00 	lds	r30, 0x00A8	; 0x8000a8 <TWI_TxTail>
 466:	f0 e0       	ldi	r31, 0x00	; 0
 468:	e0 59       	subi	r30, 0x90	; 144
 46a:	ff 4f       	sbci	r31, 0xFF	; 255
 46c:	80 81       	ld	r24, Z
 46e:	8f b9       	out	0x0f, r24	; 15
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:258
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 470:	82 e0       	ldi	r24, 0x02	; 2
 472:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    SET_USI_TO_SEND_DATA();
 476:	bc 9a       	sbi	0x17, 4	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 478:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 47a:	8e b9       	out	0x0e, r24	; 14
 47c:	92 cf       	rjmp	.-220    	; 0x3a2 <__vector_15+0x3a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:264
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 47e:	83 e0       	ldi	r24, 0x03	; 3
 480:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:265
    SET_USI_TO_READ_ACK();
 484:	bc 98       	cbi	0x17, 4	; 23
 486:	1f b8       	out	0x0f, r1	; 15
 488:	d5 cf       	rjmp	.-86     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:271
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 48a:	85 e0       	ldi	r24, 0x05	; 5
 48c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:272
    SET_USI_TO_READ_DATA();
 490:	bc 98       	cbi	0x17, 4	; 23
 492:	80 e7       	ldi	r24, 0x70	; 112
 494:	8e b9       	out	0x0e, r24	; 14
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:274
    // call slave receive callback on stop condition
    if (USI_TWI_On_Slave_Receive) {
 496:	e0 91 85 00 	lds	r30, 0x0085	; 0x800085 <USI_TWI_On_Slave_Receive>
 49a:	f0 91 86 00 	lds	r31, 0x0086	; 0x800086 <USI_TWI_On_Slave_Receive+0x1>
 49e:	30 97       	sbiw	r30, 0x00	; 0
 4a0:	09 f4       	brne	.+2      	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
 4a2:	7f cf       	rjmp	.-258    	; 0x3a2 <__vector_15+0x3a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:275
      tmpRxHead = TWI_RxHead;
 4a4:	c0 91 ab 00 	lds	r28, 0x00AB	; 0x8000ab <TWI_RxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:276
      if (TWI_RxTail != tmpRxHead) { // data in receive buffer
 4a8:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <TWI_RxTail>
 4ac:	8c 17       	cp	r24, r28
 4ae:	09 f4       	brne	.+2      	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
 4b0:	78 cf       	rjmp	.-272    	; 0x3a2 <__vector_15+0x3a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:278
        // check for stop Condition
        while ((USISR & ((1 << USI_START_COND_INT) | (1 << USIPF) | (0xE << USICNT0))) == 0)
 4b2:	8e b1       	in	r24, 0x0e	; 14
 4b4:	8e 7a       	andi	r24, 0xAE	; 174
 4b6:	e9 f3       	breq	.-6      	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:281
          ;// wait for either Start or Stop Condition
          // cancel after one SCL cycle
        if (USISR & (1 << USIPF)) { // Stop Condition
 4b8:	75 9b       	sbis	0x0e, 5	; 14
 4ba:	73 cf       	rjmp	.-282    	; 0x3a2 <__vector_15+0x3a>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 4bc:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 4c0:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <TWI_RxHead>
 4c4:	89 1b       	sub	r24, r25
 4c6:	8f 70       	andi	r24, 0x0F	; 15
__vector_15():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:282
        // check for stop Condition
        while ((USISR & ((1 << USI_START_COND_INT) | (1 << USIPF) | (0xE << USICNT0))) == 0)
          ;// wait for either Start or Stop Condition
          // cancel after one SCL cycle
        if (USISR & (1 << USIPF)) { // Stop Condition
          USI_TWI_On_Slave_Receive(USI_TWI_Data_In_Receive_Buffer());
 4c8:	90 e0       	ldi	r25, 0x00	; 0
 4ca:	09 95       	icall
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:284
          // reset rx buffer
          TWI_RxTail = tmpRxHead;
 4cc:	c0 93 ac 00 	sts	0x00AC, r28	; 0x8000ac <TWI_RxTail>
 4d0:	68 cf       	rjmp	.-304    	; 0x3a2 <__vector_15+0x3a>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 4d2:	bc 98       	cbi	0x17, 4	; 23
 4d4:	af cf       	rjmp	.-162    	; 0x434 <__LOCK_REGION_LENGTH__+0x34>

000004d6 <__vector_14>:
__vector_14():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 4d6:	1f 92       	push	r1
 4d8:	0f 92       	push	r0
 4da:	0f b6       	in	r0, 0x3f	; 63
 4dc:	0f 92       	push	r0
 4de:	11 24       	eor	r1, r1
 4e0:	2f 93       	push	r18
 4e2:	3f 93       	push	r19
 4e4:	4f 93       	push	r20
 4e6:	5f 93       	push	r21
 4e8:	6f 93       	push	r22
 4ea:	7f 93       	push	r23
 4ec:	8f 93       	push	r24
 4ee:	9f 93       	push	r25
 4f0:	af 93       	push	r26
 4f2:	bf 93       	push	r27
 4f4:	cf 93       	push	r28
 4f6:	ef 93       	push	r30
 4f8:	ff 93       	push	r31
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:169
  unsigned char tmpPin; // Temporary variable for pin state
  unsigned char tmpRxHead; // Temporary variable to store volatile
  // call slave receive callback on repeated start
  if (USI_TWI_On_Slave_Receive) {
 4fa:	e0 91 85 00 	lds	r30, 0x0085	; 0x800085 <USI_TWI_On_Slave_Receive>
 4fe:	f0 91 86 00 	lds	r31, 0x0086	; 0x800086 <USI_TWI_On_Slave_Receive+0x1>
 502:	30 97       	sbiw	r30, 0x00	; 0
 504:	81 f0       	breq	.+32     	; 0x526 <__vector_14+0x50>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:170
    tmpRxHead = TWI_RxHead;
 506:	c0 91 ab 00 	lds	r28, 0x00AB	; 0x8000ab <TWI_RxHead>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:171
    if (TWI_RxTail != tmpRxHead) { // data in receive buffer
 50a:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <TWI_RxTail>
 50e:	8c 17       	cp	r24, r28
 510:	51 f0       	breq	.+20     	; 0x526 <__vector_14+0x50>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 512:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 516:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <TWI_RxHead>
 51a:	89 1b       	sub	r24, r25
 51c:	8f 70       	andi	r24, 0x0F	; 15
__vector_14():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:172
  unsigned char tmpRxHead; // Temporary variable to store volatile
  // call slave receive callback on repeated start
  if (USI_TWI_On_Slave_Receive) {
    tmpRxHead = TWI_RxHead;
    if (TWI_RxTail != tmpRxHead) { // data in receive buffer
      USI_TWI_On_Slave_Receive(USI_TWI_Data_In_Receive_Buffer());
 51e:	90 e0       	ldi	r25, 0x00	; 0
 520:	09 95       	icall
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:174
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
 522:	c0 93 ac 00 	sts	0x00AC, r28	; 0x8000ac <TWI_RxTail>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:178
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 526:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <USI_TWI_Overflow_State>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 52a:	bc 98       	cbi	0x17, 4	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 52c:	b6 9b       	sbis	0x16, 6	; 22
 52e:	18 c0       	rjmp	.+48     	; 0x560 <__vector_14+0x8a>
 530:	b4 9b       	sbis	0x16, 4	; 22
 532:	fc cf       	rjmp	.-8      	; 0x52c <__vector_14+0x56>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 534:	88 ea       	ldi	r24, 0xA8	; 168
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 536:	8d b9       	out	0x0d, r24	; 13
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 538:	80 ef       	ldi	r24, 0xF0	; 240
 53a:	8e b9       	out	0x0e, r24	; 14
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 53c:	ff 91       	pop	r31
 53e:	ef 91       	pop	r30
 540:	cf 91       	pop	r28
 542:	bf 91       	pop	r27
 544:	af 91       	pop	r26
 546:	9f 91       	pop	r25
 548:	8f 91       	pop	r24
 54a:	7f 91       	pop	r23
 54c:	6f 91       	pop	r22
 54e:	5f 91       	pop	r21
 550:	4f 91       	pop	r20
 552:	3f 91       	pop	r19
 554:	2f 91       	pop	r18
 556:	0f 90       	pop	r0
 558:	0f be       	out	0x3f, r0	; 63
 55a:	0f 90       	pop	r0
 55c:	1f 90       	pop	r1
 55e:	18 95       	reti
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 560:	88 ef       	ldi	r24, 0xF8	; 248
 562:	e9 cf       	rjmp	.-46     	; 0x536 <__vector_14+0x60>

00000564 <main>:
main():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/main.cpp:4
#include <Arduino.h>

int main(void)
{
 564:	cf 93       	push	r28
 566:	df 93       	push	r29
 568:	00 d0       	rcall	.+0      	; 0x56a <main+0x6>
 56a:	cd b7       	in	r28, 0x3d	; 61
 56c:	de b7       	in	r29, 0x3e	; 62
init():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1077
    // normal oscillator, we want a setting that fuses won't give us,
    // so need to set prescale.
    #ifdef CCP
      CCP=0xD8; //enable change of protected register
    #else
      CLKPR=1<<CLKPCE; //enable change of protected register
 56e:	20 e8       	ldi	r18, 0x80	; 128
 570:	26 bd       	out	0x26, r18	; 38
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1080
    #endif
    #if (F_CPU ==4000000L)
      CLKPR=1; //prescale by 2 for 4MHz
 572:	91 e0       	ldi	r25, 0x01	; 1
 574:	96 bd       	out	0x26, r25	; 38
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 576:	83 e0       	ldi	r24, 0x03	; 3
 578:	80 bf       	out	0x30, r24	; 48
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 57a:	83 bf       	out	0x33, r24	; 51
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 57c:	78 94       	sei
initToneTimerInternal():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:954
    #if (TIMER_TO_USE_FOR_TONE == 0)
      // Use the Tone Timer for phase correct PWM
      TCCR0A = (1<<WGM00) | (0<<WGM01);
      TCCR0B = (ToneTimer_Prescale_Index << CS00) | (0<<WGM02);
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
 57e:	8f bd       	out	0x2f, r24	; 47
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:955
      TCCR1B = 3; //prescaler of 64
 580:	8e bd       	out	0x2e, r24	; 46
init():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 582:	85 e8       	ldi	r24, 0x85	; 133
 584:	86 b9       	out	0x06, r24	; 6
setup():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:88
 586:	26 bd       	out	0x26, r18	; 38
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:89
 588:	96 bd       	out	0x26, r25	; 38
pinMode():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 58a:	8f b7       	in	r24, 0x3f	; 63
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
 58c:	f8 94       	cli
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 58e:	d3 9a       	sbi	0x1a, 3	; 26
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 590:	8f bf       	out	0x3f, r24	; 63
setup():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:92
 592:	81 e0       	ldi	r24, 0x01	; 1
 594:	b8 de       	rcall	.-656    	; 0x306 <digitalWrite.constprop.2>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:94
 596:	84 b7       	in	r24, 0x34	; 52
 598:	8f 70       	andi	r24, 0x0F	; 15
 59a:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <registerResetReason>
loadEepromSettings():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:9
 59e:	1a 82       	std	Y+2, r1	; 0x02
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:10
 5a0:	be 01       	movw	r22, r28
 5a2:	6e 5f       	subi	r22, 0xFE	; 254
 5a4:	7f 4f       	sbci	r23, 0xFF	; 255
 5a6:	90 e0       	ldi	r25, 0x00	; 0
 5a8:	80 e0       	ldi	r24, 0x00	; 0
 5aa:	a4 de       	rcall	.-696    	; 0x2f4 <unsigned char& EEPROMClass::get<unsigned char>(int, unsigned char&) [clone .isra.1] [clone .constprop.11]>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:11
 5ac:	1a 81       	ldd	r17, Y+2	; 0x02
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:14
 5ae:	19 82       	std	Y+1, r1	; 0x01
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:15
 5b0:	be 01       	movw	r22, r28
 5b2:	6f 5f       	subi	r22, 0xFF	; 255
 5b4:	7f 4f       	sbci	r23, 0xFF	; 255
 5b6:	81 e0       	ldi	r24, 0x01	; 1
 5b8:	90 e0       	ldi	r25, 0x00	; 0
 5ba:	9c de       	rcall	.-712    	; 0x2f4 <unsigned char& EEPROMClass::get<unsigned char>(int, unsigned char&) [clone .isra.1] [clone .constprop.11]>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:16
 5bc:	89 81       	ldd	r24, Y+1	; 0x01
 5be:	80 31       	cpi	r24, 0x10	; 16
 5c0:	21 f4       	brne	.+8      	; 0x5ca <main+0x66>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:11
 5c2:	ff 24       	eor	r15, r15
 5c4:	f3 94       	inc	r15
 5c6:	17 30       	cpi	r17, 0x07	; 7
 5c8:	09 f0       	breq	.+2      	; 0x5cc <main+0x68>
main():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:17
 5ca:	f1 2c       	mov	r15, r1
 5cc:	7f e8       	ldi	r23, 0x8F	; 143
 5ce:	c7 2e       	mov	r12, r23
 5d0:	70 e0       	ldi	r23, 0x00	; 0
 5d2:	d7 2e       	mov	r13, r23
 5d4:	10 e0       	ldi	r17, 0x00	; 0
 5d6:	00 e0       	ldi	r16, 0x00	; 0
operator*():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:53

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
 5d8:	c8 01       	movw	r24, r16
 5da:	90 d1       	rcall	.+800    	; 0x8fc <eeprom_read_byte>
_ZN11EEPROMClass3getI22struct_eeprom_settingsEERT_iS3_.isra.2():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:148

    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
 5dc:	f6 01       	movw	r30, r12
 5de:	81 93       	st	Z+, r24
 5e0:	6f 01       	movw	r12, r30
 5e2:	0f 5f       	subi	r16, 0xFF	; 255
 5e4:	1f 4f       	sbci	r17, 0xFF	; 255
 5e6:	07 30       	cpi	r16, 0x07	; 7
 5e8:	11 05       	cpc	r17, r1
 5ea:	b1 f7       	brne	.-20     	; 0x5d8 <main+0x74>
checkEepromSettingsCRC():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:46
 5ec:	60 91 8f 00 	lds	r22, 0x008F	; 0x80008f <eeprom_settings>
 5f0:	61 50       	subi	r22, 0x01	; 1
 5f2:	8f e8       	ldi	r24, 0x8F	; 143
 5f4:	90 e0       	ldi	r25, 0x00	; 0
 5f6:	69 de       	rcall	.-814    	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
loadEepromSettings():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:21
 5f8:	90 91 95 00 	lds	r25, 0x0095	; 0x800095 <eeprom_settings+0x6>
 5fc:	89 13       	cpse	r24, r25
 5fe:	02 c0       	rjmp	.+4      	; 0x604 <main+0xa0>
setup():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:96
 600:	f1 10       	cpse	r15, r1
 602:	17 c0       	rjmp	.+46     	; 0x632 <main+0xce>
initializeEepromSettings():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:39
 604:	10 92 8f 00 	sts	0x008F, r1	; 0x80008f <eeprom_settings>
 608:	80 e1       	ldi	r24, 0x10	; 16
 60a:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <eeprom_settings+0x1>
 60e:	80 e5       	ldi	r24, 0x50	; 80
 610:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <eeprom_settings+0x2>
 614:	86 e0       	ldi	r24, 0x06	; 6
 616:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <eeprom_settings+0x3>
 61a:	81 e0       	ldi	r24, 0x01	; 1
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	90 93 94 00 	sts	0x0094, r25	; 0x800094 <eeprom_settings+0x5>
 622:	80 93 93 00 	sts	0x0093, r24	; 0x800093 <eeprom_settings+0x4>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_EEPROM.ino:40
 626:	7a de       	rcall	.-780    	; 0x31c <saveEepromSettings()>
setup():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:99
 628:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <registerResetReason>
 62c:	80 61       	ori	r24, 0x10	; 16
 62e:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <registerResetReason>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:102
 632:	81 b5       	in	r24, 0x21	; 33
 634:	90 91 92 00 	lds	r25, 0x0092	; 0x800092 <eeprom_settings+0x3>
 638:	88 7d       	andi	r24, 0xD8	; 216
 63a:	29 2f       	mov	r18, r25
 63c:	27 70       	andi	r18, 0x07	; 7
 63e:	82 2b       	or	r24, r18
 640:	99 0f       	add	r25, r25
 642:	99 0f       	add	r25, r25
 644:	90 72       	andi	r25, 0x20	; 32
 646:	89 2b       	or	r24, r25
 648:	81 bd       	out	0x21, r24	; 33
startI2C():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:226
 64a:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <eeprom_settings+0x2>
begin():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:373

  USI_TWI_Master_Initialise();
}

void TwoWire::begin(uint8_t address) {
  BufferIndex = 0;
 64e:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <TwoWire::BufferIndex>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:374
  BufferLength = 0;
 652:	10 92 ae 00 	sts	0x00AE, r1	; 0x8000ae <TwoWire::BufferLength>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:375
  transmitting = 0;
 656:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <TwoWire::transmitting>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:377

  USI_TWI_Slave_Initialise(address);
 65a:	a1 dd       	rcall	.-1214   	; 0x19e <USI_TWI_Slave_Initialise>
onReceive():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:600
  // XXX: to be implemented.
}

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) ) {
  USI_TWI_On_Slave_Receive = function;
 65c:	87 e3       	ldi	r24, 0x37	; 55
 65e:	91 e0       	ldi	r25, 0x01	; 1
 660:	90 93 86 00 	sts	0x0086, r25	; 0x800086 <USI_TWI_On_Slave_Receive+0x1>
 664:	80 93 85 00 	sts	0x0085, r24	; 0x800085 <USI_TWI_On_Slave_Receive>
onRequest():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:605
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) ) {
  USI_TWI_On_Slave_Transmit = function;
 668:	8a ee       	ldi	r24, 0xEA	; 234
 66a:	90 e0       	ldi	r25, 0x00	; 0
 66c:	90 93 84 00 	sts	0x0084, r25	; 0x800084 <USI_TWI_On_Slave_Transmit+0x1>
 670:	80 93 83 00 	sts	0x0083, r24	; 0x800083 <USI_TWI_On_Slave_Transmit>
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:214
 674:	bb 24       	eor	r11, r11
 676:	ba 94       	dec	r11
USI_TWI_Slave_Disable():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:92
void USI_TWI_Slave_Disable()
{
  DDR_USI_CL &= ~(1 << PORT_USI_SCL);  // Set SCL as input
  DDR_USI &= ~(1 << PORT_USI_SDA);  // Set SDA as input
  USICR = 0x00; // Disable USI
  USISR = 0xF0; // Clear all flags and reset overflow counter
 678:	60 ef       	ldi	r22, 0xF0	; 240
 67a:	a6 2e       	mov	r10, r22
onReceive():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:600
  // XXX: to be implemented.
}

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) ) {
  USI_TWI_On_Slave_Receive = function;
 67c:	07 e3       	ldi	r16, 0x37	; 55
 67e:	11 e0       	ldi	r17, 0x01	; 1
onRequest():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:605
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) ) {
  USI_TWI_On_Slave_Transmit = function;
 680:	7c 01       	movw	r14, r24
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:111
 682:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <receiveEventData>
 686:	85 30       	cpi	r24, 0x05	; 5
 688:	09 f4       	brne	.+2      	; 0x68c <main+0x128>
 68a:	c6 c0       	rjmp	.+396    	; 0x818 <main+0x2b4>
 68c:	70 f5       	brcc	.+92     	; 0x6ea <main+0x186>
 68e:	82 30       	cpi	r24, 0x02	; 2
 690:	09 f4       	brne	.+2      	; 0x694 <main+0x130>
 692:	83 c0       	rjmp	.+262    	; 0x79a <main+0x236>
 694:	48 f4       	brcc	.+18     	; 0x6a8 <main+0x144>
 696:	88 23       	and	r24, r24
 698:	09 f4       	brne	.+2      	; 0x69c <main+0x138>
 69a:	4d c0       	rjmp	.+154    	; 0x736 <main+0x1d2>
 69c:	81 30       	cpi	r24, 0x01	; 1
 69e:	09 f4       	brne	.+2      	; 0x6a2 <main+0x13e>
 6a0:	77 c0       	rjmp	.+238    	; 0x790 <main+0x22c>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:214
 6a2:	b0 92 96 00 	sts	0x0096, r11	; 0x800096 <receiveEventData>
 6a6:	71 c0       	rjmp	.+226    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:111
 6a8:	83 30       	cpi	r24, 0x03	; 3
 6aa:	09 f4       	brne	.+2      	; 0x6ae <main+0x14a>
 6ac:	94 c0       	rjmp	.+296    	; 0x7d6 <main+0x272>
 6ae:	84 30       	cpi	r24, 0x04	; 4
 6b0:	c1 f7       	brne	.-16     	; 0x6a2 <main+0x13e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:147
 6b2:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 6b6:	88 23       	and	r24, r24
 6b8:	21 f3       	breq	.-56     	; 0x682 <main+0x11e>
analogReference():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:45
{
  // can't actually set the register here because the default setting
  // will connect AVCC and the AREF pin, which would cause a short if
  // there's something connected to AREF.
  // fix? Validate the mode?
  analog_reference = mode;
 6ba:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <analog_reference>
 6be:	98 e0       	ldi	r25, 0x08	; 8
 6c0:	99 2e       	mov	r9, r25
main():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:250
 6c2:	d1 2c       	mov	r13, r1
 6c4:	c1 2c       	mov	r12, r1
readVCCVoltage():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:253
 6c6:	80 e2       	ldi	r24, 0x20	; 32
 6c8:	5b dd       	rcall	.-1354   	; 0x180 <analogRead>
 6ca:	c8 0e       	add	r12, r24
 6cc:	d9 1e       	adc	r13, r25
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:254
 6ce:	36 dd       	rcall	.-1428   	; 0x13c <noIntDelay(unsigned char) [clone .constprop.3]>
 6d0:	9a 94       	dec	r9
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:251
 6d2:	91 10       	cpse	r9, r1
 6d4:	f8 cf       	rjmp	.-16     	; 0x6c6 <main+0x162>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:256
 6d6:	83 e0       	ldi	r24, 0x03	; 3
 6d8:	d6 94       	lsr	r13
 6da:	c7 94       	ror	r12
 6dc:	8a 95       	dec	r24
 6de:	e1 f7       	brne	.-8      	; 0x6d8 <main+0x174>
 6e0:	d0 92 8d 00 	sts	0x008D, r13	; 0x80008d <registerVCCVoltage+0x1>
 6e4:	c0 92 8c 00 	sts	0x008C, r12	; 0x80008c <registerVCCVoltage>
 6e8:	50 c0       	rjmp	.+160    	; 0x78a <main+0x226>
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:111
 6ea:	88 30       	cpi	r24, 0x08	; 8
 6ec:	09 f4       	brne	.+2      	; 0x6f0 <main+0x18c>
 6ee:	c5 c0       	rjmp	.+394    	; 0x87a <main+0x316>
 6f0:	e0 f4       	brcc	.+56     	; 0x72a <main+0x1c6>
 6f2:	86 30       	cpi	r24, 0x06	; 6
 6f4:	09 f4       	brne	.+2      	; 0x6f8 <main+0x194>
 6f6:	a2 c0       	rjmp	.+324    	; 0x83c <main+0x2d8>
 6f8:	87 30       	cpi	r24, 0x07	; 7
 6fa:	99 f6       	brne	.-90     	; 0x6a2 <main+0x13e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:176
 6fc:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 700:	83 30       	cpi	r24, 0x03	; 3
 702:	08 f4       	brcc	.+2      	; 0x706 <main+0x1a2>
 704:	42 c0       	rjmp	.+132    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:178
 706:	d0 90 99 00 	lds	r13, 0x0099	; 0x800099 <receiveEventData+0x3>
 70a:	62 e0       	ldi	r22, 0x02	; 2
 70c:	87 e9       	ldi	r24, 0x97	; 151
 70e:	90 e0       	ldi	r25, 0x00	; 0
 710:	dc dd       	rcall	.-1096   	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
 712:	d8 12       	cpse	r13, r24
 714:	3a c0       	rjmp	.+116    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:180
 716:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <receiveEventData+0x1>
 71a:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <receiveEventData+0x2>
 71e:	90 93 94 00 	sts	0x0094, r25	; 0x800094 <eeprom_settings+0x5>
 722:	80 93 93 00 	sts	0x0093, r24	; 0x800093 <eeprom_settings+0x4>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:181
 726:	fa dd       	rcall	.-1036   	; 0x31c <saveEepromSettings()>
 728:	30 c0       	rjmp	.+96     	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:111
 72a:	89 30       	cpi	r24, 0x09	; 9
 72c:	89 f1       	breq	.+98     	; 0x790 <main+0x22c>
 72e:	8f 3f       	cpi	r24, 0xFF	; 255
 730:	09 f0       	breq	.+2      	; 0x734 <main+0x1d0>
 732:	b7 cf       	rjmp	.-146    	; 0x6a2 <main+0x13e>
 734:	ff cf       	rjmp	.-2      	; 0x734 <main+0x1d0>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:114
 736:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 73a:	82 30       	cpi	r24, 0x02	; 2
 73c:	30 f1       	brcs	.+76     	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:116
 73e:	d0 90 98 00 	lds	r13, 0x0098	; 0x800098 <receiveEventData+0x2>
 742:	61 e0       	ldi	r22, 0x01	; 1
 744:	87 e9       	ldi	r24, 0x97	; 151
 746:	90 e0       	ldi	r25, 0x00	; 0
 748:	c0 dd       	rcall	.-1152   	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
 74a:	d8 12       	cpse	r13, r24
 74c:	1e c0       	rjmp	.+60     	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:118
 74e:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <receiveEventData+0x1>
 752:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <eeprom_settings+0x2>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:119
 756:	e2 dd       	rcall	.-1084   	; 0x31c <saveEepromSettings()>
USI_TWI_Slave_Disable():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:89
}

// Disable USI for TWI Slave mode.
void USI_TWI_Slave_Disable()
{
  DDR_USI_CL &= ~(1 << PORT_USI_SCL);  // Set SCL as input
 758:	be 98       	cbi	0x17, 6	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:90
  DDR_USI &= ~(1 << PORT_USI_SDA);  // Set SDA as input
 75a:	bc 98       	cbi	0x17, 4	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:91
  USICR = 0x00; // Disable USI
 75c:	1d b8       	out	0x0d, r1	; 13
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:92
  USISR = 0xF0; // Clear all flags and reset overflow counter
 75e:	ae b8       	out	0x0e, r10	; 14
end():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:386
  begin((uint8_t)address);
}

void TwoWire::end(void) {
  USI_TWI_Slave_Disable();
  DDR_USI_CL &= ~(1 << PIN_USI_SCL); // Enable SCL as input.
 760:	be 98       	cbi	0x17, 6	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:387
  DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 762:	bc 98       	cbi	0x17, 4	; 23
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:388
  PORT_USI &= ~(1 << PIN_USI_SDA); // Disable pullup on SDA.
 764:	c4 98       	cbi	0x18, 4	; 24
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:389
  PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Disable pullup on SCL.
 766:	c6 98       	cbi	0x18, 6	; 24
startI2C():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:226
 768:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <eeprom_settings+0x2>
begin():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:373

  USI_TWI_Master_Initialise();
}

void TwoWire::begin(uint8_t address) {
  BufferIndex = 0;
 76c:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <TwoWire::BufferIndex>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:374
  BufferLength = 0;
 770:	10 92 ae 00 	sts	0x00AE, r1	; 0x8000ae <TwoWire::BufferLength>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:375
  transmitting = 0;
 774:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <TwoWire::transmitting>
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:377

  USI_TWI_Slave_Initialise(address);
 778:	12 dd       	rcall	.-1500   	; 0x19e <USI_TWI_Slave_Initialise>
onReceive():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:600
  // XXX: to be implemented.
}

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) ) {
  USI_TWI_On_Slave_Receive = function;
 77a:	10 93 86 00 	sts	0x0086, r17	; 0x800086 <USI_TWI_On_Slave_Receive+0x1>
 77e:	00 93 85 00 	sts	0x0085, r16	; 0x800085 <USI_TWI_On_Slave_Receive>
onRequest():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:605
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) ) {
  USI_TWI_On_Slave_Transmit = function;
 782:	f0 92 84 00 	sts	0x0084, r15	; 0x800084 <USI_TWI_On_Slave_Transmit+0x1>
 786:	e0 92 83 00 	sts	0x0083, r14	; 0x800083 <USI_TWI_On_Slave_Transmit>
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:215
 78a:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <receiveEventData+0x11>
 78e:	79 cf       	rjmp	.-270    	; 0x682 <main+0x11e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:126
 790:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 794:	81 11       	cpse	r24, r1
 796:	f9 cf       	rjmp	.-14     	; 0x78a <main+0x226>
 798:	74 cf       	rjmp	.-280    	; 0x682 <main+0x11e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:133
 79a:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 79e:	88 23       	and	r24, r24
 7a0:	09 f4       	brne	.+2      	; 0x7a4 <main+0x240>
 7a2:	6f cf       	rjmp	.-290    	; 0x682 <main+0x11e>
analogReference():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:45
 7a4:	81 e0       	ldi	r24, 0x01	; 1
 7a6:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <analog_reference>
 7aa:	58 e0       	ldi	r21, 0x08	; 8
 7ac:	95 2e       	mov	r9, r21
main():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:237
 7ae:	d1 2c       	mov	r13, r1
 7b0:	c1 2c       	mov	r12, r1
readTemperature():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:240
 7b2:	82 e2       	ldi	r24, 0x22	; 34
 7b4:	e5 dc       	rcall	.-1590   	; 0x180 <analogRead>
 7b6:	c8 0e       	add	r12, r24
 7b8:	d9 1e       	adc	r13, r25
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:241
 7ba:	c0 dc       	rcall	.-1664   	; 0x13c <noIntDelay(unsigned char) [clone .constprop.3]>
 7bc:	9a 94       	dec	r9
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:238
 7be:	91 10       	cpse	r9, r1
 7c0:	f8 cf       	rjmp	.-16     	; 0x7b2 <main+0x24e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:243
 7c2:	43 e0       	ldi	r20, 0x03	; 3
 7c4:	d6 94       	lsr	r13
 7c6:	c7 94       	ror	r12
 7c8:	4a 95       	dec	r20
 7ca:	e1 f7       	brne	.-8      	; 0x7c4 <main+0x260>
 7cc:	d0 92 88 00 	sts	0x0088, r13	; 0x800088 <registerTemperature+0x1>
 7d0:	c0 92 87 00 	sts	0x0087, r12	; 0x800087 <registerTemperature>
 7d4:	da cf       	rjmp	.-76     	; 0x78a <main+0x226>
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:140
 7d6:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 7da:	88 23       	and	r24, r24
 7dc:	09 f4       	brne	.+2      	; 0x7e0 <main+0x27c>
 7de:	51 cf       	rjmp	.-350    	; 0x682 <main+0x11e>
analogReference():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_analog.c:45
 7e0:	80 91 8e 00 	lds	r24, 0x008E	; 0x80008e <registerADCReference>
 7e4:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <analog_reference>
 7e8:	38 e0       	ldi	r19, 0x08	; 8
 7ea:	93 2e       	mov	r9, r19
main():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:263
 7ec:	d1 2c       	mov	r13, r1
 7ee:	c1 2c       	mov	r12, r1
readVBAT():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:266
 7f0:	81 e2       	ldi	r24, 0x21	; 33
 7f2:	c6 dc       	rcall	.-1652   	; 0x180 <analogRead>
 7f4:	c8 0e       	add	r12, r24
 7f6:	d9 1e       	adc	r13, r25
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:267
 7f8:	a1 dc       	rcall	.-1726   	; 0x13c <noIntDelay(unsigned char) [clone .constprop.3]>
 7fa:	9a 94       	dec	r9
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:264
 7fc:	91 10       	cpse	r9, r1
 7fe:	f8 cf       	rjmp	.-16     	; 0x7f0 <main+0x28c>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:269
 800:	82 e2       	ldi	r24, 0x22	; 34
 802:	be dc       	rcall	.-1668   	; 0x180 <analogRead>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:270
 804:	23 e0       	ldi	r18, 0x03	; 3
 806:	d6 94       	lsr	r13
 808:	c7 94       	ror	r12
 80a:	2a 95       	dec	r18
 80c:	e1 f7       	brne	.-8      	; 0x806 <main+0x2a2>
 80e:	d0 92 8a 00 	sts	0x008A, r13	; 0x80008a <registerVBAT+0x1>
 812:	c0 92 89 00 	sts	0x0089, r12	; 0x800089 <registerVBAT>
 816:	b9 cf       	rjmp	.-142    	; 0x78a <main+0x226>
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:154
 818:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 81c:	82 30       	cpi	r24, 0x02	; 2
 81e:	08 f4       	brcc	.+2      	; 0x822 <main+0x2be>
 820:	b4 cf       	rjmp	.-152    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:156
 822:	d0 90 98 00 	lds	r13, 0x0098	; 0x800098 <receiveEventData+0x2>
 826:	61 e0       	ldi	r22, 0x01	; 1
 828:	87 e9       	ldi	r24, 0x97	; 151
 82a:	90 e0       	ldi	r25, 0x00	; 0
 82c:	4e dd       	rcall	.-1380   	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
 82e:	d8 12       	cpse	r13, r24
 830:	ac cf       	rjmp	.-168    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:158
 832:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <receiveEventData+0x1>
 836:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <registerADCReference>
 83a:	a7 cf       	rjmp	.-178    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:164
 83c:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 840:	82 30       	cpi	r24, 0x02	; 2
 842:	08 f4       	brcc	.+2      	; 0x846 <main+0x2e2>
 844:	a2 cf       	rjmp	.-188    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:166
 846:	d0 90 98 00 	lds	r13, 0x0098	; 0x800098 <receiveEventData+0x2>
 84a:	61 e0       	ldi	r22, 0x01	; 1
 84c:	87 e9       	ldi	r24, 0x97	; 151
 84e:	90 e0       	ldi	r25, 0x00	; 0
 850:	3c dd       	rcall	.-1416   	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
 852:	d8 12       	cpse	r13, r24
 854:	9a cf       	rjmp	.-204    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:168
 856:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <receiveEventData+0x1>
 85a:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <eeprom_settings+0x3>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:169
 85e:	5e dd       	rcall	.-1348   	; 0x31c <saveEepromSettings()>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:170
 860:	81 b5       	in	r24, 0x21	; 33
 862:	90 91 92 00 	lds	r25, 0x0092	; 0x800092 <eeprom_settings+0x3>
 866:	88 7d       	andi	r24, 0xD8	; 216
 868:	29 2f       	mov	r18, r25
 86a:	27 70       	andi	r18, 0x07	; 7
 86c:	82 2b       	or	r24, r18
 86e:	99 0f       	add	r25, r25
 870:	99 0f       	add	r25, r25
 872:	90 72       	andi	r25, 0x20	; 32
 874:	89 2b       	or	r24, r25
 876:	81 bd       	out	0x21, r24	; 33
 878:	88 cf       	rjmp	.-240    	; 0x78a <main+0x226>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:187
 87a:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <receiveEventData+0x11>
 87e:	87 30       	cpi	r24, 0x07	; 7
 880:	08 f4       	brcc	.+2      	; 0x884 <main+0x320>
 882:	0f cf       	rjmp	.-482    	; 0x6a2 <main+0x13e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:189
 884:	d0 90 9c 00 	lds	r13, 0x009C	; 0x80009c <receiveEventData+0x6>
 888:	65 e0       	ldi	r22, 0x05	; 5
 88a:	87 e9       	ldi	r24, 0x97	; 151
 88c:	90 e0       	ldi	r25, 0x00	; 0
 88e:	1d dd       	rcall	.-1478   	; 0x2ca <computeCRC8(unsigned char*, unsigned char)>
 890:	d8 12       	cpse	r13, r24
 892:	07 cf       	rjmp	.-498    	; 0x6a2 <main+0x13e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:191
 894:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <receiveEventData+0x1>
 898:	83 35       	cpi	r24, 0x53	; 83
 89a:	09 f0       	breq	.+2      	; 0x89e <main+0x33a>
 89c:	02 cf       	rjmp	.-508    	; 0x6a2 <main+0x13e>
 89e:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <receiveEventData+0x2>
 8a2:	8c 34       	cpi	r24, 0x4C	; 76
 8a4:	09 f0       	breq	.+2      	; 0x8a8 <main+0x344>
 8a6:	fd ce       	rjmp	.-518    	; 0x6a2 <main+0x13e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:192
 8a8:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <receiveEventData+0x3>
 8ac:	85 34       	cpi	r24, 0x45	; 69
 8ae:	09 f0       	breq	.+2      	; 0x8b2 <main+0x34e>
 8b0:	f8 ce       	rjmp	.-528    	; 0x6a2 <main+0x13e>
 8b2:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <receiveEventData+0x4>
 8b6:	85 34       	cpi	r24, 0x45	; 69
 8b8:	09 f0       	breq	.+2      	; 0x8bc <main+0x358>
 8ba:	f3 ce       	rjmp	.-538    	; 0x6a2 <main+0x13e>
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:193
 8bc:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <receiveEventData+0x5>
 8c0:	80 35       	cpi	r24, 0x50	; 80
 8c2:	09 f0       	breq	.+2      	; 0x8c6 <main+0x362>
 8c4:	ee ce       	rjmp	.-548    	; 0x6a2 <main+0x13e>
digitalRead():
C:\Users\pc235\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:180
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
 8c6:	89 b3       	in	r24, 0x19	; 25
loop():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:196
 8c8:	83 fb       	bst	r24, 3
 8ca:	88 27       	eor	r24, r24
 8cc:	80 f9       	bld	r24, 0
 8ce:	91 e0       	ldi	r25, 0x01	; 1
 8d0:	89 27       	eor	r24, r25
 8d2:	19 dd       	rcall	.-1486   	; 0x306 <digitalWrite.constprop.2>
 8d4:	e6 ce       	rjmp	.-564    	; 0x6a2 <main+0x13e>

000008d6 <_GLOBAL__sub_I_eeprom_settings>:
_GLOBAL__sub_I_eeprom_settings():
C:\Users\pc235\AppData\Local\Temp\arduino_build_659634\sketch/smol_Power_Board_AAA_ATtiny43U_EEPROM.h:3
// smôl Power Board AAA EEPROM storage and fuctions

struct struct_eeprom_settings {
 8d6:	ef e8       	ldi	r30, 0x8F	; 143
 8d8:	f0 e0       	ldi	r31, 0x00	; 0
 8da:	10 82       	st	Z, r1
 8dc:	80 e1       	ldi	r24, 0x10	; 16
 8de:	81 83       	std	Z+1, r24	; 0x01
 8e0:	80 e5       	ldi	r24, 0x50	; 80
 8e2:	82 83       	std	Z+2, r24	; 0x02
 8e4:	86 e0       	ldi	r24, 0x06	; 6
 8e6:	83 83       	std	Z+3, r24	; 0x03
 8e8:	81 e0       	ldi	r24, 0x01	; 1
 8ea:	90 e0       	ldi	r25, 0x00	; 0
 8ec:	95 83       	std	Z+5, r25	; 0x05
 8ee:	84 83       	std	Z+4, r24	; 0x04
__base_ctor ():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U.ino:71
 8f0:	e6 e9       	ldi	r30, 0x96	; 150
 8f2:	f0 e0       	ldi	r31, 0x00	; 0
 8f4:	8f ef       	ldi	r24, 0xFF	; 255
 8f6:	80 83       	st	Z, r24
 8f8:	11 8a       	std	Z+17, r1	; 0x11
_GLOBAL__sub_I_eeprom_settings():
C:\Users\pc235\Documents\GitHub\SparkX_smôl_Power_Board_AAA\Firmware\smol_Power_Board_AAA_ATtiny43U/smol_Power_Board_AAA_ATtiny43U_IO.ino:85
 8fa:	08 95       	ret

000008fc <eeprom_read_byte>:
eeprom_read_byte():
 8fc:	e1 99       	sbic	0x1c, 1	; 28
 8fe:	fe cf       	rjmp	.-4      	; 0x8fc <eeprom_read_byte>
 900:	8e bb       	out	0x1e, r24	; 30
 902:	e0 9a       	sbi	0x1c, 0	; 28
 904:	99 27       	eor	r25, r25
 906:	8d b3       	in	r24, 0x1d	; 29
 908:	08 95       	ret

0000090a <eeprom_write_byte>:
eeprom_write_byte():
 90a:	26 2f       	mov	r18, r22

0000090c <eeprom_write_r18>:
 90c:	e1 99       	sbic	0x1c, 1	; 28
 90e:	fe cf       	rjmp	.-4      	; 0x90c <eeprom_write_r18>
 910:	1c ba       	out	0x1c, r1	; 28
 912:	8e bb       	out	0x1e, r24	; 30
 914:	2d bb       	out	0x1d, r18	; 29
 916:	0f b6       	in	r0, 0x3f	; 63
 918:	f8 94       	cli
 91a:	e2 9a       	sbi	0x1c, 2	; 28
 91c:	e1 9a       	sbi	0x1c, 1	; 28
 91e:	0f be       	out	0x3f, r0	; 63
 920:	01 96       	adiw	r24, 0x01	; 1
 922:	08 95       	ret

00000924 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 924:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 926:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 928:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 92a:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 92c:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 92e:	09 94       	ijmp

00000930 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 930:	f8 94       	cli

00000932 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 932:	ff cf       	rjmp	.-2      	; 0x932 <__stop_program>
